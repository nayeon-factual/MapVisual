<html lang="en">
    <head>
        <title> Color Geocode Visual </title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <!--Mapbox-->
        <script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
        <link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css' rel='stylesheet' />
        <!--style sheet-->
        <link href='colorClusterMapVisual.css' rel='stylesheet' type='text/css'/>
        <!--bootstrap-->
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
        <!--jquery-->
        <script src="//code.jquery.com/jquery-1.11.1.js"></script>
        <!--Slider-->
        <link rel="stylesheet" href="//code.jquery.com/ui/1.11.0/themes/smoothness/jquery-ui.css">
        <script src="//code.jquery.com/jquery-1.10.2.js"></script>
        <script src="//code.jquery.com/ui/1.11.0/jquery-ui.js"></script>
    </head>
    
    <body>
        <!--MapBox MarkerCluster Plugin-->
        <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/leaflet.markercluster.js'></script>
        <link href='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/MarkerCluster.css' rel='stylesheet'/>
        <link href='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/MarkerCluster.Default.css' rel='stylesheet'/>
        
        <!--MapBox Draw & Geodesy Plugin-->
        <link href='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-draw/v0.2.2/leaflet.draw.css' rel='stylesheet' />
        <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-draw/v0.2.2/leaflet.draw.js'></script>
        <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-geodesy/v0.1.0/leaflet-geodesy.js'></script>
        
        
        <div id = "map"></div>
        <div id = "dataTable">
            <table id = "mapDataTable" class = "table table-hover table-condensed">
                <tr>
                    <th> Name </th>
                    <th> Locality </th>
                    <th> Latitude </th>
                    <th> Longitude </th>
                </tr>
            </table>
        </div>
        <div id = "messages">
            <table id = "msgTable" class = "table table-striped table-condensed">
                    <tr>
                        <th> img </th>
                        <th> Message </th>
                    </tr>
                </table>
        </div>

        <script>
            //LOAD MAP
            var map = L.mapbox.map('map', 'nayeon-factual.ik2lag96')
                .setView([38, -102.0], 9);
            
            //LOAD POINTS
            var featureLayer = L.mapbox.featureLayer()
                .loadURL('map.geojson')
            
            featureLayer.on('ready', function(layer) {
                map.fitBounds(featureLayer.getBounds());
                
                 // Initially populate mapDataTable with first 100 data points
                // ***TODO*** set behavior for when there is initially < 100 data points
                // featureLayer._geojson returns entire featureCollection, iterate through. 
                var featCol = featureLayer._geojson;
                for (i = 0; i < 100; i++) {
                    var name = featCol.features[i].properties.name;
                    var loc = featCol.features[i].properties.locality;
                    var lat = featCol.features[i].geometry.coordinates[0];
                    var lng = featCol.features[i].geometry.coordinates[1];
                    $("#mapDataTable").append("<tr><td>" + name + "</td>" + "<td>" + loc + "</td>" + "<td>" + lat + "</td>" + "<td>" + lng + "</td></tr>");
                }
                                
                var markers = new L.MarkerClusterGroup({
                    maxClusterRadius: 40,
                    // polygonOptions:{}, 
                    // ***TODO*** instead of using childcount to change color of cluster, use stDev. (sm,med,lg to zero_realred, low_red, med_green, high_blue stdev) and rather than set 3 pre-determined values of colors, fill the shade of the icon dynamically hsb(0-100,40-100%, 30-70)
//                    iconCreateFunction: function(cluster) { 
//                        var c = ' marker-cluster-';
                    
                    
//                            if (stDev < .4) {
//                                c += 'low';
//                            } else if (childCount < 1) {
//                                c += 'medium';
//                            } else {
//                                c += 'high';
//                            }
                    
                    
//                        return new L.DivIcon({ html: '<div><span>' + childCount + stDev '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40)})
//                    }
                });
                
                    // Highlight in DataTable when Mouse Hovers over a Marker
                    markers.on('mouseover', function (a) {
                        var row = document.getElementById(a.layer.toGeoJSON().properties.name);
                        console.log(a.layer.toGeoJSON().properties.name);
                            row.className = "active";
                    })
                            
                    markers.on('mouseout', function (a) {
                        var row = document.getElementById(a.layer.toGeoJSON().properties.name);
                            row.className = " ";
                    })        
                    
                    // Populate mapDataTable when a Marker is Clicked
                    markers.on('click', function (a) {
                        //a.layer is [object object] = represents marker
                        var markerObject = a.layer.toGeoJSON();
                        var clickedName = markerObject.properties.name;
                        var clickedLoc = markerObject.properties.locality;
                        var clickedLat = markerObject.geometry.coordinates[0];
                        var clickedLng = markerObject.geometry.coordinates[1];
                        $("#mapDataTable").html("<tr><th>Name</th><th>Locality</th><th>Latitude</th><th>Longitude</th></tr>");
                        $("#mapDataTable").append('<tr id="'+clickedName+'"><td>' + clickedName +"</td>"+"<td>"+clickedLoc+"</td>"+"<td>"+clickedLat+"</td>"+"<td>"+clickedLng+"</td></tr>");
                        
                    });
                
                
                    // Define Behaviors when Mouse Hovers over a Cluster
                    markers.on('clustermouseover', function (a) {
                        var markerObject = a.layer.toGeoJSON();
                        
                        //Cluster Boundary Polygon Object
                        var boundPolygon = L.polygon(a.layer.getConvexHull());
                        //Area of Cluster Boundary in km^2
                        var boundArea = (LGeo.area(boundPolygon) / 1000000).toFixed(2);
                        var clusterDensity = boundArea/a.layer.getChildCount();
                        // All child markers of the cluster
                        var clusterMarkers = a.layer.getAllChildMarkers();
                        // Calculating LatLng of the Centroid of the Cluster
                        var latXTotal = 0;
                        var latYTotal = 0;
                        var lonDegreesTotal = 0;
                        var currentLatLng;
                        
                        for (c = 0; c < clusterMarkers.length; c++) {
                            currentLatLng = clusterMarkers[c]._latlng;
                            var latDeg = currentLatLng.lat;
                            var lonDeg = currentLatLng.lng;
                            var latRad = Math.PI * latDeg / 180;
                            
                            latXTotal += Math.cos(latRad);
                            latYTotal += Math.sin(latRad);
                            lonDegreesTotal += lonDeg;
                        }
                        
                        var centrLatRad = Math.atan2(latYTotal, latXTotal);
                        //Centroid Coordinates: (centrLatDeg, centrLonDeg)
                        var centrLatDeg = centrLatRad * 180 / Math.PI;
                        var centrLonDeg = lonDegreesTotal / clusterMarkers.length;
                        
                        // Calculating Standard of Deviation for all Markers in Cluster
                        // Compare and average distances between all points and centroid
                        var R = 6371; //earth's radius approx.
                        var centrLonRad = Math.PI * centrLonDeg / 180;
                        var distSum = 0;
                        
                        for (s = 0; s < clusterMarkers.length; s++) {
                            
                            // Use Haversine Formula for Distance Between All Markers and Centroid
                            var otherLat = clusterMarkers[s]._latlng.lat;
                            var otherLon = clusterMarkers[s]._latlng.lng;
                            var deltaLat = Math.PI * (otherLat - centrLatDeg) / 180; //deltaLat in Rad
                            var deltaLng = Math.PI * (otherLon - centrLonDeg) / 180; //deltaLng in Rad

                            var step1 = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) + 
                                Math.cos(centrLatRad) * Math.cos(Math.PI *  otherLat/180) 
                                * Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
                            var step2 = 2*Math.atan2(Math.sqrt(step1), Math.sqrt(1-step1));

                            var dist = R * step2
                            distSum += dist;
                            }
                        
                        var stDev = distSum / clusterMarkers.length;
                        
                        // Popup Displays boundArea, clusterDensity, stDev upon hover
                        a.layer.bindPopup('clusterArea: ' + boundArea + ' km<sup>2</sup><br />clusterDensity: ' + clusterDensity + ' km<sup>2</sup> per marker <br /> standard of Dev: ' + stDev);
                        a.layer.openPopup();
                        
                        // Highlight in DataTable when Mouse Hovers over a Cluster
                        for (i = 0; i < a.layer.getAllChildMarkers().length; i++) {
                            var clusterName = a.layer.getAllChildMarkers()[i].toGeoJSON().properties.name;
                            console.log(clusterName);
                            var row = document.getElementById(clusterName);
                            row.className = "active";
                        }
                        
                        });
                        markers.on('clustermouseout', function (a) {
                            for (i = 0; i < a.layer.getAllChildMarkers().length; i++) {
                            var clusterName = a.layer.getAllChildMarkers()[i].toGeoJSON().properties.name;
                            var row = document.getElementById(clusterName);
                            row.className = " ";
                        }
                        });
                
                
                        //Populate mapDataTable when Cluster is Clicked
                        markers.on('clusterclick', function (a) {
                           
                        //a.layer.getAllChildMarkers() returns an array; getAllChildMarkers().length is childcount
                        //console.log('cluster ' + a.layer.getAllChildMarkers().length);
                        // ** TODO ** only populate table with top 100 if childCount > 100 
                        $("#mapDataTable").html("<tr><th>Name</th><th>Locality</th><th>Latitude</th><th>Longitude</th></tr>");
                        for (i = 0; i < a.layer.getAllChildMarkers().length; i++) {
                            var clusterClickName = a.layer.getAllChildMarkers()[i].toGeoJSON().properties.name;
                            var clusterClickLoc = a.layer.getAllChildMarkers()[i].toGeoJSON().properties.locality;
                            var clusterClickLat = a.layer.getAllChildMarkers()[i].toGeoJSON().geometry.coordinates[0];
                            var clusterClickLng = a.layer.getAllChildMarkers()[i].toGeoJSON().geometry.coordinates[1];
                            $("#mapDataTable").append('<tr id="'+clusterClickName+'"><td>'+clusterClickName+"</td>"+"<td>"+clusterClickLoc+"</td>"+"<td>"+clusterClickLat+"</td>"+"<td>"+ clusterClickLng+"</td></tr>");
                        }
                    });
                
                this.eachLayer(function(marker) {
                    markers.addLayer(marker);
                    //console.log('markerlatlng'+marker.getLatLng());
                    //console.log('fitBounds '+markers.addLayer(marker));
                });
                map.addLayer(markers);
            });
            
            /*featureLayer.on('ready', function(layer) {
                map.fitBounds(featureLayer.getBounds());
                
                var markers = new L.MarkerClusterGroup( {
                    maxClusterRadius: 30,
//                    polygonOptions: {
//                        color: "#fff" - stroke color
//                          opacity: 
//                            fillColor/fillOpacity
//                            className
//                    },
//                    iconCreateFunction: 
//                        function (cluster) {
//                            return new L.DivIcon({
//                                className: 'prism',
//                                html: cluster.getChildCount(),
//                                iconSize: [16, 16]
//                            });
//                        }
                });
            */
        </script>
    </body>

</html>

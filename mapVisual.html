<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title> Map Visual </title>
<meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
<script src="//code.jquery.com/jquery-1.10.2.js"></script>
    
    
<script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css' rel='stylesheet' />
  
    
<style>
* {
  margin:0;
  padding:0;
}

body {
  background-image: url(http://subtlepatterns.com/patterns/black_lozenge.png);
}
    
#world {
      perspective: 500px;
}

#map {
  background-color: #222;
  margin: 0 auto;
  height: 600px;
  width: 600px;
  transform-style: preserve-3d;
  box-shadow:
    20px 20px 100px 10px rgba(0,0,0,0.3),
    50px 50px 200px 10px rgba(0,0,0,0.2);	
  
    transform:
    translateX(0px)
    translateY(-260px)
    translateZ(-10px)
    rotateX(30deg)
    rotateY(0deg);
    transform-origin-x: 100%;
    transform-origin-y: 50%;
}

</style>
</head>

    
<body>
    
<div id='world'>
    <div id='map'></div>
</div>
    
<script>
//LOAD MAP
var map = L.mapbox.map('map', 'nayeon-factual.ik2lag96')
    .setView([38, -102.0], 9);
//LOAD POINTS
var featureLayer = L.mapbox.featureLayer()
    .loadURL('map.geojson')
    .addTo(map);

    
//FIT TO MARKERS    
featureLayer.on('ready', function() {
    // featureLayer.getBounds() returns the corners of the furthest-out markers, and map.fitBounds() makes sure that the map contains these.
    map.fitBounds(featureLayer.getBounds());
});
    
    
    
// props
var boundsRotateX     = {max: 10, min: -30},
    boundsRotateZ     = {max: 20, min: -20}, 
    targetRotation    = {x: 20, y: 0, z: 0},
    currentRotation   = targetRotation;
    
// interpolate
function lerp(start, stop, t) {
  return (stop - start) * t + start;
}
    
// re-maps a number from one range to another
function map(value, fromLow, fromHigh, toLow, toHigh) {
  var fromDiff   = fromHigh - fromLow,
      toDiff     = toHigh - toLow,
      ratio      = toDiff / fromDiff;
  return toLow + (value - fromLow) * ratio;
}


// main animation loop; interpolates to the value of targetRotation
(function tick() {
  currentRotation = { x: lerp(currentRotation.x, targetRotation.x, 0.05),
                      y: lerp(currentRotation.y, targetRotation.y, 0.05),
                      z: lerp(currentRotation.z, targetRotation.z, 0.05)};

// render rotation of the device
$("#map").css("transform:", "rotateX(" + currentRotation.x + "deg) rotateY(" + currentRotation.y + "deg) rotateZ(" + currentRotation.z + "deg)  translateX(0px) translateY(-50px) translateZ(-50px)");
  requestAnimationFrame(tick);
})();

// update the target rotation value when the user moves the mouse. y position controls x rotation, x position controls z rotation, currently not modifying the y rotation.
$("html").on("mousemove", function(e) {
  targetRotation  = {x: map(e.clientY, 0, $("html").height(), boundsRotateX.min, boundsRotateX.max) * -1,
                     y: 0,
                     z: map(e.clientX, 0, $("html").width(), boundsRotateZ.min, boundsRotateZ.max) * -1};
});    
    
</script>
</body>
</html>
